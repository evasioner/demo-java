1. Database 생성

   1. create databse stdb;
   2. use stdb;

2. Table 생성

   1. t1 생성

      ```mysql
      drop table if exists t1;
      
      create table t1 (
        id  bigint unsigned not null primary key auto_increment
      , c1  varchar(10)
      , c2  varchar(10)
      , qty   bigint unsigned not null default 0
      , price bigint unsigned not null default 0
      ) engine = innodb default charset=utf8;
      
      desc t1;
      ```

   2. t2 생성

      ```mysql
      drop table if exists t2;
      
      create table t2 (
        id  bigint unsigned not null primary key auto_increment
      , c1  varchar(10)
      , c2  varchar(10)
      , qty   bigint unsigned not null default 0
      , price bigint unsigned not null default 0
      ) engine = innodb default charset=utf8;
      
      desc t2;
      ```

3. 데이터 생성

   1. t1 데이터 생성

      ```mysql
      insert into t1 (id, c1, c2, qty, price)
      select @no := @no +1 as id
           , @no  as c1
           , lpad(@no, 10, 0)  as c2
           , cast(rand() * 500   as unsigned) as qty
           , cast(rand() * 10000 as unsigned) as price
        from (select @no := 0) a
           , information_schema.columns b
           , information_schema.columns c
           , information_schema.columns d
       limit 50000000;
      ```

      

   2. t2 데이터 생성 

      ```mysql
      insert into t2 (id, c1, c2, qty, price)
      select @no := @no +1 as id
           , @no  as c1
           , lpad(@no, 10, 0)  as c2
           , cast(rand() * 500   as unsigned) as qty
           , cast(rand() * 10000 as unsigned) as price
        from (select @no := 0) a
           , information_schema.columns b
           , information_schema.columns c
           , information_schema.columns d
       limit 50000000;
      ```

      약 30분소요

4. PK (Primary key)

   - 테이블 당 PK 한개 만 생성 가능
   - Oracle의 rowid 효과를 내기 위해 auto increment를 활용하여 PK 생성
   - Order By 등 sort 활용할때 사용

5.  쿼리 explain 

   ```mysql
   desc select * from t1 where id = 100;
   explain format=JSON  select * from t1 where id = 100;
   ```

6. 형변환 테스트

   ```mysql
   desc select * from t1 where id = 100;
   desc select id from t1 where id = concat(100);
   ```

7. None Index

   ```mysql
   desc select c1 from t1 where c1 = 100; 
   ```

8. Index 생성

   ```mysql
   create index idx_t1_c1 on stdb.t1 (c1);
   desc select c1 from t1 where c1 = 100;
   ```

9. 컬럼가공

   1. 

10. Composite Index

    ```mysql
    SELECT TABLE_SCHEMA,TABLE_NAME,INDEX_NAME,GROUP_CONCAT(COLUMN_NAME SEPARATOR ',') AS COLUMN_NAMES
    FROM information_schema.STATISTICS
    where TABLE_SCHEMA = 'stdb'
    GROUP BY TABLE_SCHEMA,TABLE_NAME,INDEX_NAME;
    
    create index idx_t1_m1 on t1(c2,price);
    create index idx_t1_m2 on t1(price,c2);
    create index idx_t1_m3 on t1(id,c1,c2);
    
    desc select count(*) from t1 where price >= 1000 and price < 5000;
    ** Index를 올바르게 사용함에 있어서 중요한 포인트.
    query 3. idx_t1_m2 사용 하겠지만...성능은 안좋겠지...
    desc select * from t1 use index (idx_t1_m1) where price >= 1000 and c2 = '0000899995';
    desc select * from t1 use index (idx_t1_m2) where price >= 1000 and c2 = '0000899995';
    
    ```

    

11. JOIN

    ```mysql
    * ANSI SQL 사용.
    * MySQL에서는 NL Join만 사용 된다고 보면 됨. (8.1.18 최신버전에서는 Hash 조인도 가능함.)
    
    create unique index idx_t2_c1 on t2(c1);
    create unique index idx_t2_c2 on t2(c2);
    
    
    select a.*, b.* from t1 a, t2 b where a.id = b.id;
    
    explain format=JSON select a.id, b.id from t1 a inner join t2 b on a.id = b.id where a.id = 899995\G
    explain format=JSON select a.id, b.* from t1 a inner  join t2 b on a.id = b.id where a.id = 899995\G
    
    desc select a.id, b.id from t1 a inner join t2 b on a.id = b.id where a.id = 899995;
    desc select a.id, b.* from t1 a inner  join t2 b on a.id = b.id where a.id = 899995;
    
    desc select a.id, b.id from t1 a inner join t2 b on a.id = b.id where a.c2 = '0000899995';
    
    
    desc select a.*, b.* from t1 a inner join t2 b on a.id = b.c1 where b.c2 = '0000899995';
    desc select a.*, b.* from t1 a inner join t2 b on a.c1 = b.c1 where b.c2 = '0000899995';
    
    ```

12. UNION, UNION ALL

    ```mysql
    * union은 중복 제거 작업을 함. 성능 저하.
    * union all 중복 제거 작업이 없음. 어차피 where 조건이 다르기 때문에 중복 제거를 하지 않음.
    
    create index idx_독일차 on 독일차(차종류,차색깔)
    
    select 차 가격 From 독일차 where 차종류 = '벤츠' and 차색깔 = '빨강'
    union
    select 차 가격 From 독일차 where 차종류 = '벤츠' and 차색깔 = '파랑';
    
    select 차 가격 From 독일차 where 차종류 = '벤츠' and 차색깔 = '빨강'
    union all
    select 차 가격 From 독일차 where 차종류 = '벤츠' and 차색깔 = '파랑';
    
    ```

13. TIP

    1. 대용량 테이블 Insert 할때는..
       테이블 생성 -> 인덱스 생성 -> Insert 하는것 보다. 
       테이블 생성 -> Insert -> 인덱스 생성이 좋음. (인덱스를 미리 만들어 두면, 정렬 하면서 Insert 하기 때문에..느림.)

    2. ```mysql
       subquery 보다는 join 형태로 쿼리를 작성하는 것이 좋다.
       
       select a.c2,a.price,a.qty from t1 a
       where a.id in (
         select id from t2 where id between 1 and 10
       );
       
       --> 변환
       
       select a.c2,a.price,a.qty 
       from t1 a inner join t2 b on a.id = b.id
       where b.id between 1 and 10;
       ```

       